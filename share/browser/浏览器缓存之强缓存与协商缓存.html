<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器缓存之强缓存与协商缓存 | 大斑马的小屋</title>
    <meta name="description" content="大斑马的小屋">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/zebra/assets/css/0.styles.70b966b2.css" as="style"><link rel="preload" href="/zebra/assets/js/app.34ae22a4.js" as="script"><link rel="preload" href="/zebra/assets/js/2.c6624801.js" as="script"><link rel="preload" href="/zebra/assets/js/6.6e72e674.js" as="script"><link rel="prefetch" href="/zebra/assets/js/10.0ed91c18.js"><link rel="prefetch" href="/zebra/assets/js/11.3ad5732c.js"><link rel="prefetch" href="/zebra/assets/js/12.a83928e4.js"><link rel="prefetch" href="/zebra/assets/js/13.c0a21f7f.js"><link rel="prefetch" href="/zebra/assets/js/14.1b9602a4.js"><link rel="prefetch" href="/zebra/assets/js/15.abe7bccd.js"><link rel="prefetch" href="/zebra/assets/js/3.6cf60747.js"><link rel="prefetch" href="/zebra/assets/js/4.2b2cd21e.js"><link rel="prefetch" href="/zebra/assets/js/5.25e441f8.js"><link rel="prefetch" href="/zebra/assets/js/7.8a59eeab.js"><link rel="prefetch" href="/zebra/assets/js/8.aea4707f.js"><link rel="prefetch" href="/zebra/assets/js/9.a544c69d.js">
    <link rel="stylesheet" href="/zebra/assets/css/0.styles.70b966b2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zebra/" class="home-link router-link-active"><img src="/zebra/assets/img/zebra-3.png" alt="大斑马的小屋" class="logo"> <span class="site-name can-hide">大斑马的小屋</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zebra/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分享小屋" class="dropdown-title"><span class="title">分享小屋</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zebra/share/vue/Vuex 原理.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/js/五个 JavaScript 小技巧.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/security/最基础的 Web 安全问题.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/monitor/基于 CentOS 7 搭建异常监控 Sentry.html" class="nav-link">
  前端监控
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zebra/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分享小屋" class="dropdown-title"><span class="title">分享小屋</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zebra/share/vue/Vuex 原理.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/js/五个 JavaScript 小技巧.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html" class="nav-link">
  浏览器
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/security/最基础的 Web 安全问题.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/zebra/share/monitor/基于 CentOS 7 搭建异常监控 Sentry.html" class="nav-link">
  前端监控
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浏览器</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html" class="active sidebar-link">浏览器缓存之强缓存与协商缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#浏览器缓存机制过程" class="sidebar-link">浏览器缓存机制过程</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#expires" class="sidebar-link">Expires</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#cache-control" class="sidebar-link">Cache-Control</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#expires-cache-control" class="sidebar-link">Expires &amp; Cache-Control</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#查看浏览器已经成功应用使用了强缓存" class="sidebar-link">查看浏览器已经成功应用使用了强缓存</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#disk-cache-memory-cache" class="sidebar-link">disk cache &amp; memory cache</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#last-modified" class="sidebar-link">Last-Modified</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#etag" class="sidebar-link">ETag</a></li><li class="sidebar-sub-header"><a href="/zebra/share/browser/浏览器缓存之强缓存与协商缓存.html#last-modified-etag" class="sidebar-link">Last-Modified &amp; Etag</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器缓存之强缓存与协商缓存"><a href="#浏览器缓存之强缓存与协商缓存" class="header-anchor">#</a> 浏览器缓存之强缓存与协商缓存</h1> <h1 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h1> <p>浏览器缓存机制在性能优化中扮演重要的一环。优秀的缓存策略能够缩短请求网页的距离、降低延迟和网络负荷、减少请求带宽。那该如何应用好浏览器缓存，我们需要对其原理有一定认识。</p> <h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="header-anchor">#</a> 浏览器缓存机制</h1> <p>浏览器中缓存可分为强缓存和协商缓存。具体判断使用那种缓存机制，是通过 http header 字段的不同。</p> <h2 id="浏览器缓存机制过程"><a href="#浏览器缓存机制过程" class="header-anchor">#</a> 浏览器缓存机制过程</h2> <ul><li>浏览器加载资源，根据资源的 http header 判断是否命中强缓存；
<ul><li>若命中：浏览器直接从自己缓存中读取资源，不会发生 http 请求到服务器；</li> <li>没有命中：浏览器会发送请求到服务器，通过服务器中 http header 验证这个资源是否命中协商缓存；
<ul><li>命中：请求返回，但不返回资源，告诉客户端可直接从缓存中加载；</li> <li>没有命中：请求返回，返回资源；</li></ul></li></ul></li></ul> <p>可以得出：强缓存与协商缓存区别：强缓存不发生请求到服务器，协商缓存会发请求到服务器。
下面，我们需要知道 http header 如何判断命中强缓存和协商缓存的。</p> <h1 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h1> <h2 id="expires"><a href="#expires" class="header-anchor">#</a> <strong>Expires</strong></h2> <div class="language-shell extra-class"><pre class="language-shell"><code>Expires: Thu, <span class="token number">21</span> Nov <span class="token number">2019</span> 07:48:15 GMT
</code></pre></div><p>Expires 是 HTTP/1.0 控制网页缓存的字段。其值为服务器返回该请求结果缓存的<strong>到期时间</strong>，即如果发生时间在 Expires 之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源；是绝对时间；</p> <h2 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> <strong>Cache-Control</strong></h2> <p>Cache-Control 是 HTTP/1.1 新增的规则，用于控制网页缓存的字段。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/svg/424608/1582080482135-366582ab-d065-488b-8806-e38bbd2e3dd6.svg" alt=""></p> <ul><li>示例分析</li></ul> <blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582080528811-7310bf51-9919-44f3-985f-6f71bdc87480.png#align=left&amp;display=inline&amp;height=141&amp;name=image.png&amp;originHeight=348&amp;originWidth=730&amp;size=43795&amp;status=done&amp;style=shadow&amp;width=295" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582080756091-ac20d1bf-5450-4b6f-b8e2-0f9aaf68b059.png#align=left&amp;display=inline&amp;height=165&amp;name=image.png&amp;originHeight=510&amp;originWidth=734&amp;size=64495&amp;status=done&amp;style=shadow&amp;width=238" alt="image.png"></p></blockquote> <ul><li><strong>cache-control:</strong> max-age=2592000,s-maxage=3600
<ul><li>max-age: 资源第一次的请求时间和 Cache-Control max-age 设定的有效期，计算出资源过期时间；再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则不行。是相对时间；</li></ul></li> <li><strong>cache-control:</strong> public, max-age=31536000
<ul><li>public 可以被所有用户浏览器缓存，包括代理服务器，时长为第一次请求资源时间与31536000秒之和。</li></ul></li></ul> <h2 id="expires-cache-control"><a href="#expires-cache-control" class="header-anchor">#</a> Expires &amp; Cache-Control</h2> <p>我们需要知道 Cache-Control 与 Expires  同时存在的话(如下图)，Cache-Control** 的优先级高于 **<strong>Expires</strong></p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582080879475-3d10a7d5-ad7a-4a8e-af03-beedca12353b.png#align=left&amp;display=inline&amp;height=227&amp;name=image.png&amp;originHeight=622&amp;originWidth=744&amp;size=78245&amp;status=done&amp;style=shadow&amp;width=272" alt="image.png"></p> <p>因为Expires时间返回的是服务器绝对时间，而客户端本地时间是可以修改的(时区不同等)，造成服务器与客户端时间发生误差，强缓存会直接失效。而 Cache-Control 是相对时间，每次参照客户端第一次请求时间计算而来的，故不会受到影响；毕竟 Cache-Control 是 HTTP/1.1 新增的规范</p> <h2 id="查看浏览器已经成功应用使用了强缓存"><a href="#查看浏览器已经成功应用使用了强缓存" class="header-anchor">#</a> 查看浏览器已经成功应用使用了强缓存</h2> <p>一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存. Chrome 下的现象如下
200 OK disk cache 或者200 OK from memory cache</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582082433135-8c16f923-1e2b-4969-951d-c125621bfddd.png#align=left&amp;display=inline&amp;height=119&amp;name=image.png&amp;originHeight=238&amp;originWidth=598&amp;size=26962&amp;status=done&amp;style=shadow&amp;width=299" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582082386169-a02a8448-9174-4af4-8dde-1a90ddf87113.png#align=left&amp;display=inline&amp;height=119&amp;name=image.png&amp;originHeight=238&amp;originWidth=700&amp;size=30296&amp;status=done&amp;style=shadow&amp;width=350" alt="image.png"></p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582082011873-ae638104-7978-4311-8c25-6b1003fae9f8.png#align=left&amp;display=inline&amp;height=226&amp;name=image.png&amp;originHeight=638&amp;originWidth=2044&amp;size=223045&amp;status=done&amp;style=shadow&amp;width=724" alt="image.png"></p> <h2 id="disk-cache-memory-cache"><a href="#disk-cache-memory-cache" class="header-anchor">#</a> disk cache &amp; memory cache</h2> <p>看到上图，应该会有疑问，from memory cache 和 from disk cache 又分别代表的是什么呢？
根据英文名 memory disk ，我们需要知道内存缓存和硬盘缓存两个概念；</p> <h3 id="内存缓存"><a href="#内存缓存" class="header-anchor">#</a> 内存缓存</h3> <blockquote><p>内存缓存即 memory cache</p></blockquote> <blockquote><p>内存缓存有两个特点 快速读取 和 时效性
    快速读取：会将解析编译资源放入到进程中的内存，占据一定内存资源，方便下次快速读取    时效性：一旦进程关闭，进程的内存会被清空</p></blockquote> <h3 id="硬盘缓存"><a href="#硬盘缓存" class="header-anchor">#</a> 硬盘缓存</h3> <blockquote><p>硬盘缓存即 disk cache</p></blockquote> <blockquote><p>硬盘缓存将数据写入到磁盘文件，读取缓存需要读取硬盘文件进行 I/O 操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p></blockquote> <h3 id="读取缓存时机"><a href="#读取缓存时机" class="header-anchor">#</a> 读取缓存时机</h3> <p><strong>什么时候从内存缓存读取，什么时候从硬盘缓存读取？</strong>
在浏览器中，浏览器会在 JS 和图片等文件解析执行后直接存入内存缓存中，那么当 刷新 页面时，直接从内存缓存from memory cache 中读取，而 CSS 比较大的文件则会存入硬盘文件，所以每次渲染页面都需要从磁盘读取缓存from disk cache。</p> <ul><li>根据例子解释说明</li></ul> <blockquote><p>打开一个网页此时是开启一个新进程，内存中还没缓存文件。所以从硬盘缓存 from disk cache 中读取，如下图</p></blockquote> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582083662506-32ae6dfe-7d37-44dc-b0f6-16d1165623dd.png#align=left&amp;display=inline&amp;height=242&amp;name=image.png&amp;originHeight=626&amp;originWidth=1930&amp;size=210605&amp;status=done&amp;style=shadow&amp;width=746" alt="image.png"></p> <blockquote><p>当刷新网页，内存中已经有缓存缓存文件，故有的会从内存缓存 from memory cache 中读取</p></blockquote> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582083703931-3866d531-7912-46f4-bde8-3223a39b4993.png#align=left&amp;display=inline&amp;height=142&amp;name=image.png&amp;originHeight=404&amp;originWidth=2126&amp;size=147650&amp;status=done&amp;style=shadow&amp;width=746" alt="image.png"></p> <h1 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h1> <h2 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h2> <div class="language-shell extra-class"><pre class="language-shell"><code>Last-Modified: Wed, <span class="token number">21</span> Nov <span class="token number">2018</span> 05:46:58 GMT
If-Modified-Since: Wed, <span class="token number">21</span> Nov <span class="token number">2018</span> 05:46:58 GMT
</code></pre></div><p><strong>具体过程如下：</strong></p> <ul><li>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，会在 Respone 的 Header 的 Last-Modified 值设置为，该资源最后修改的时间；</li> <li>2、第二次请求的时候，在 Request 的 Header 上加上 If-Modified-Since，值为上次请求资源的 Last-Modified；</li> <li>3、服务器收到 If-Modified-Since 与服务器文件的 Last-Modified 比对，
<ul><li>命中：无变化则返回 304，不返回资源。浏览器收到 304 使用本地缓存；不更新 Last-Modified；</li> <li>不命中：有变化返回200，重新更新 Last-Modified、返回 200、返回资源。</li></ul></li></ul> <h2 id="etag"><a href="#etag" class="header-anchor">#</a> ETag</h2> <blockquote><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code>ETag: <span class="token string">&quot;d5d-55b192d5e0640&quot;</span>
If-None-Match: <span class="token string">&quot;d5d-55b192d5e0640&quot;</span>
</code></pre></div><p><strong>具体过程如下：</strong></p> <ul><li>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，会在 Respone 的 Header 的 ETag 值设置为，该资源当前资源文件的一个唯一标识；</li> <li>2、第二次请求的时候，在 Request 的 Header 上加上 If-None-Match，值为上次请求资源的 ETag；</li> <li>3、服务器收到 If-None-Match 与服务器文件的 ETag 比对，
<ul><li>命中：一致则返回 304，代表资源无更新，故不返回资源。浏览器将会收到 304 使用本地缓存；更新 ETag；</li> <li>不命中：不一致返回 200，重新更新 ETag、返回 200、返回资源。</li></ul></li></ul> <p>我们可以得知具体过程与 Last-Modified 过程一致，只有有一点区别如下：</p> <ul><li>当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，Respone 的 Header 还会把这个ETag 返回，即使这个 ETag 跟之前的没有变化。</li></ul> <h2 id="last-modified-etag"><a href="#last-modified-etag" class="header-anchor">#</a> Last-Modified &amp; Etag</h2> <p>Last-Modified 与 ETag 是可以一起使用的（见下图），**服务器会优先验证 **ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304 Not Modified。</p> <p>ETag 可以解决 Last-Modified 存在的一些问题，**既生 **Last-Modified **何生 **ETag?</p> <ul><li>文件内容不更改，但修改时间发生改变，这个时候不希望客户端认为这个文件修改了。</li> <li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1S 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 S 级的，这种修改无法判断；</li> <li>某些服务器不能精确的得到文件的最后修改时间。</li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582092084291-d6b8879e-81dd-4784-90d3-3c296e0f690d.png#align=left&amp;display=inline&amp;height=175&amp;name=image.png&amp;originHeight=350&amp;originWidth=750&amp;size=44047&amp;status=done&amp;style=none&amp;width=375" alt="image.png"> <img src="https://cdn.nlark.com/yuque/0/2020/png/424608/1582094474388-ddd9edc3-6734-47c7-8f62-a5833c3837f3.png#align=left&amp;display=inline&amp;height=63&amp;name=image.png&amp;originHeight=126&amp;originWidth=2022&amp;size=40194&amp;status=done&amp;style=none&amp;width=1011" alt="image.png"></p> <h1 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h1> <p>强缓存会优先于协商缓存，若强缓存 ( Expires / Cache-Control ) 生效，直接不发送请求直接使用本地资源；不生效接着进行协商缓存。协商缓存 ( Last-Modified / ETag ) 由服务器进行判断，若文件失效，返回新的资源，否则返回 304，不返回资源。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/zebra/assets/js/app.34ae22a4.js" defer></script><script src="/zebra/assets/js/2.c6624801.js" defer></script><script src="/zebra/assets/js/6.6e72e674.js" defer></script>
  </body>
</html>
