# JS引擎的执行机制 Event Loop

# JS引擎的执行机制 Event Loop

- 1、JS特点
- 2、JS为什么是单线程的?
- 3、JS为什么需要异步？
- 4、什么是Event Loop【浏览器中】
- 5、Event Loop【Node】
- 6、进程 线程 锁
- 7、总结

## 关键字

`单线程` `进程` `线程` `浏览器进程线程` `异步` `EventLoop` `执行栈` `任务队列` `微任务` `宏任务`

## 1、JS特点

> JS是单线程


## 2、JS为什么是单线程的?

### 2.1进程与线程

相信大家经常会听到 JS 是_单线程_执行的，那什么是线程？

- 2.1.1 进程
  - 解释：本质上来说，两个名词都是 _CPU 工作时间片_的一个描述。
  - 描述：进程描述了 CPU 在_运行指令及加载和保存上下文_所需的时间，放在应用上来说就代表了一个程序。
- 2.1.2 线程
  - 解释：_线程是进程中的更小单位_，描述了_执行一段指令_所需的时间。
- 2.1.3 浏览器的进程线程
  - 把这些概念拿到浏览器中来说，当你打开一个页面时，_其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP请求线程等等_。
  - 当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。
  - 2.1.3.1 JS单线程的好处
    - JS 引擎线程和渲染线程，大家应该都知道，在 _JS 运行的时候可能会阻止 UI_ 渲染，这说明了_JS引擎线程和渲染线程互斥_
    - 这其中的原因是_因为JS可以修改DOM_，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于JS是单线程运行的，
    - _可以达到节省内存，节约上下文切换时间_，没有锁的问题的好处。当然前面两点在服务端中更容易体现。
    - Javascript 在设计之初的定位是用来处理用户交互以及操作 DOM
    - 其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。
  - 2.1.3.2 锁
    - 对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。
    - 解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。

## 3、JS为什么需要异步？

### 3.1 如果JS中不存在异步

- 如果JS中不存在异步, 只能自上而下执行, 如果上一行解析时间很长, 那么下面的代码就_会被阻塞_。对于用户而言, 阻塞就意味着"_卡死_", 这样就导致了很差的_用户体验_
- 因为 JavaScript 是单线程的。_单线程就意味着，所有任务需要排队_，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。_为了协调_事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。
- JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?

## 4、什么是Event Loop【浏览器中】

> JS这种运行机制又称为 Event Loop(事件循环)


### 4.1运行机制

- 4.1.1 执行栈
  - 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
  - 特点：可以把执行栈认为是一个_存储函数调用的栈结构_，遵循先进后出的原则。后执行的函数会先弹出栈
  - 执行：当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。
- 4.1.2 任务队列
  - 主线程之外，事件触发线程管理着一个任务队列,只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。_任务队列_(task queue)。
  - 其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中
  - 特点：先进先出
- 4.1.3 栈队列在EventLoop之间运行机制
  - 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
  - 我们执行 JS 代码的时候其实就是_往执行栈中放入函数_，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 _Task（有多种 Task）_ 队列中。一旦执行栈为空，Event Loop 就会从 Task _队列中拿出需要执行的代码并放入执行栈_中执行，所以本质上来说 JS 中的异步还是同步行为。
- 4.1.4 哪些是异步任务
  - 不同的任务源会被_分配到不同的 Task 队列中_，任务源可以分为 _微任务（microtask_） 和 _宏任务（macrotask）_。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。下面来看以下代码的执行顺序：
  - _微任务_包括 process.nextTick ，promise ，MutationObserver(监听一个DOM变动， 当DOM对象树发生任何变动时，Mutation Observer会得到通知)，其中 process.nextTick 为 Node 独有
  - _宏任务_包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering requestAnimationFrame
- 4.1.5 异步代码执行顺序
  - **认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。**
  - 首先执行同步代码，这属于宏任务
  - 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
  - 执行所有微任务
  - 当执行完所有微任务后，如有必要会渲染页面
  - 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数
  - Node: process.nextTick优先级高于Promise.then

## 5、Event Loop【Node】

Node 中的 Event Loop 和浏览器中的有什么区别？process.nexttick 执行顺序？
Node 中的 Event Loop 和浏览器中的是完全不相同的东西。
Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。
当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段

## 6、进程 线程 锁

### 6.1 进程

- 6.1.1 为什么要引入**进程**？

为了使程序能**可靠**的并发，于是把程序包装成进程，**程序**以进程实体的方式驻留在内存，**轮流**占用**CPU**执行。
- 6.1.2 进程特征？ **进程的特征**：结构特征(进程实体)、动态性(生命周期)、并发性、异步性、独立性。
- 6.1.3 进程的三种基本状态及其转换关系
> ![](https://cdn.nlark.com/yuque/0/2019/png/424608/1566469874340-8546a0eb-2c81-4544-855b-327c3d297fd2.png#align=left&display=inline&height=356&originHeight=356&originWidth=483&size=0&status=done&width=483)

- 进程控制块(PCB)是进程存在的唯一标志。为什么呢？
  - <1>:为了描述和控制进程的运行，系统为每个进程定义了一个数据结构--进程控制块PCB(Process Control Block),它是进程实体的一部分，是操作系统中最重要的**记录型数据**结构。
  - <2>:PCB中记录了操作系统所需的、用于描述进程当前情况以及**控制进程**运行的全部**信息**。进程控制块的**作用**是使一个在多道程序环境下不能独立运行的程序，**成为**一个能与其他程序**并发**执行的进程。也就是OS根据**PCB来对并发执行的进程进行控制和管理的。**
  - <3>:在调度某些进程后，要根据其PCB中所保存的处理机状态信息，设置该进程**恢复**运行的现场，并根据PCB中的程序和数据内存**始址**，找到其程序和数据，进程在执行过程中，当需要与之合作的进程是实现**同步、通信或者访问文件**时，也都需要访问PCB；当进程由于某种原因而**暂停**执行时，又需要将其**断点**的处理机环境保存在PCB中
  - <4>:所以在进程的整个生命周期中，系统总是通过PCB对进程进行控制，所以，系统是根据**进程的PCB而不是任何别的什么而感知到该进程的存在**，所以PCB是进程存在的唯一标志。
- 6.1.4 **进程同步**：诸进程在并发执行时存在直接和间接两种相互制约关系。
- 6.1.5 **临界资源与临界区**：每个进程中访问临界资源的那段代码称为临界区。
- 6.1.6 **同步机制四准则**：空闲让进，忙则等待，有限等待，让权等待。
- 6.1.7 **进程同步 – 信号量(Semaphore)机制**
  - 整型信号量与记录型信号量从用户角度来看是一样的，均包含两个原子操作wait(S)和signal(S)，或称PV原语。wait操作申请一个单位资源，将S值减少1；signal操作释放一个单位资源，将S值增加1。整型信号量因未遵循**让权等待**准则而被记录型信号量取代。
  - **互斥信号量**的初值是1。资源信号量的当前值代表该类临界资源的可用数量，注意：若资源信号量的当前值是负数，则该资源当前可用数量为0，且其**绝对值**代表正在排队阻塞等待该资源的进程数量。例如与打印机相关的信号量S=-3，则打印机当前可用数量为0台，且有3个进程正在排队阻塞等待该打印机。

信号量可用于实现进程间**互斥及同步。**
- 6.1.8 **进程间通信**(IPC)
  - 信号量机制是卓有成效的同步工具，但不是卓有成效的进程间通信工具。于是我们介绍了三种高级进程间通信机制：管道、共享存储区、消息队列。

### 6.2 线程

- 6.2.1 为什么要引入**线程**？**比较线程与进程**？
  - 在操作系统中引入进程的目的，是为了使多个程序能**并发执行**，以提高资源的**利用率**和系统的**吞吐量**，那么在操作系统中在引入线程，则是为了减少程序在**并发执行**时所付出的**时空开销**。使OS具有更好的**并发性**。

线程具有许多传统进程所具有的特征，所以又称为轻型进程或进程元，相应的把传统进程称为重型进程
  - <1>**调度**：在传统的操作系统中，作为拥有资源的基本单位和独立调度，分派的基本单位都是进程，而在引入进程的操作系统中，则把**线程**作为**调度和分派**的基本单位，而进程作为**资源拥有**的基本单位，这样线程便能轻装上阵，显著提高系统的并发性。同一进程中，线程的切换不会引起进程的切换，但是一个进程中的线程到另一个进程中的线程时， 将会引起进程的切换。
  - <2>**并发性**：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使操作系统具有更好的并发性，从而能够有效提高系统资源的利用率和吞吐量。
  - <3>**拥有资源**：不论是传统操作系统，还是引入线程的，进程都可以拥有资源，是系统中拥有资源的一个基本单位，线程自己不拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，即一个进程的代码段，数据段以及拥有的系统资源。可以供该进程中的所有线程所共享。
  - <4>**系统开销**：在创建或者撤销进程时， 系统都要有之创建和回收进程控制块，分配或回收资源，如内存控件和I/O设备，操作系统所付出开销明显大于线程创建或撤销的时的开销，线程切换则仅需要保存和设置绍亮的寄存器内容。由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比较容易，在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。

### 6.3 调度与死锁

1. **高级调度**(作业调度)是从**外存**的**后备**队列中选择某个或某些作业优先调入内存。
1. **低级调度**(进程调度)是从**内存**的**就绪**队列中选择某个进程使它优先获得CPU进入执行态。
1. 进程调度有**抢占式**、**非抢占式**两种方式。抢占调度方式主要基于**优先权原则**、**短进程优先原则**或**时间片原则**
1. **先来先服务调度算法**:先来先服务(First Come First Served, FCFS)调度算法是一种最简单的调度算法，既可以用于作业调度，也可以用于进程调度。有**利于长**作业（进程），**不利于短**作业（进程）；有利于CPU繁忙型的作业，不利于I/O繁忙型的作业。
1. **短作业(进程)优先调度算法**：短作业优先(Shortest Job First, SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入**内存**运行。类似的，短进程优先(SPF)算法从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，直到其执行至完成或阻塞时再重新调度。
1. **短作业(进程)优先调度算法优点**：相比于先来先服务调度算法，可改善平均周转时间及平均带权周转时间，尤其是对短作业，会有明显改善。从而有效**降低**作业的平均**等待**时间，提高系统**吞吐量**。

**缺点**：1）对长作业不利，会导致长作业(进程)长期不被调度(Starvation)；2）完全未考虑作业的紧迫程度；3）作业(进程)的长短是预估的，不一定准确。
1. 产生**死锁的原因**可归结为**竞争资源**、**进程间推进顺序不当**。
1. 产生死锁的**四大必要条件**，其中的互斥条件不仅不能摒弃，还必须保证

**1：互斥条件**（访问临界资源）

**2：请求和保持条件**。进程已保持了至少一个资源，又因提出新的资源请求而阻塞，阻塞期间对自己已获得的资源保持不放。

**3：不剥夺条件**

**4：环路等待条件**。发生死锁时，必然存在一个进程——资源的环链，即进程集合{P0,P1,…,Pn}，P0正在等待P1占用的资源，P1正在等待P2占用的资源，…… ，Pn正在等待P0占用的资源。
1. **处理死锁的四种方法**：**预防死锁**（摒弃哪几个必要条件？），**避免**死锁，**检测**死锁，**解除**死锁（剥夺资源、撤销进程）。
1. **预防死锁**（**摒弃**哪几个必要条件？）

摒弃“请求与保持”条件

摒弃“不剥夺”条件

摒弃“环路等待”条件
1. **避免死锁**( 系统的安全状态与不安全状态)

**安全状态**，是指系统能按某种进程顺序，即安全序列〈P1，P2，… ，Pn〉，来为每个进程Pi分配所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于**不安全状态**。

当系统进入不安全状态后，便有可能进而进入死锁状态。避免死锁的**实质**在于：**系统在进行资源分配时，如何避免系统进入不安全状态**。

## 7、总结

- JS是单线程
- Event Loop(事件循环)是JS运行机制
- 执行栈 存放同步任务 遵循先进后出的原则
- 任务队列 存放异步任务 先进先出
- 微任务 包括 process.nextTick，promise，MutationObserver，其中 process.nextTick 为 Node 独有
- 宏任务 包括 script，setTimeout ，setInterval，setImmediate，I/O，UI rendering requestAnimationFrame
- 我们执行 JS 代码的时候其实就是_往执行栈中放入函数_，遇到异步的代码时，会被挂起并在需要执行的时候加入到 _Task（有多种 Task）_ 队列中。一旦执行栈为空，Event Loop 就会从 Task _队列中拿出需要执行的代码并放入执行栈_中执行，所以本质上来说 JS 中的异步还是同步行为。
- Node: process.nextTick优先级高于Promise.then
- EventLoop执行顺序
  - 宏任务 - 微任务 - 渲染 - 宏任务 - 微任务 - 渲染
  - 微任务 - 渲染 - 宏任务 - 微任务 - 渲染

## 分享

[Event Loop](https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-18)
[8张图让你一步步看清 async/await 和 promise 的执行顺序](https://segmentfault.com/a/1190000017224799)
[深入理解JS引擎的执行机制](https://segmentfault.com/a/1190000012806637)
[Eventloop不可怕，可怕的是遇上Promise](https://juejin.im/post/5c9a43175188252d876e5903#heading-5)
[中高级前端」从多线程来看 Event Loop](https://juejin.im/post/5d5b4c2df265da03dd3d73e5)
